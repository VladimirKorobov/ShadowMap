diff --git a/ShadowMap/Bin/water.vsh b/ShadowMap/Bin/water.vsh
index 82c2426..512a1d9 100755
--- a/ShadowMap/Bin/water.vsh
+++ b/ShadowMap/Bin/water.vsh
@@ -17,45 +17,51 @@ out vec3 vsNormal;
 out vec4 vsPosition;
 out float vsAlpha;
 
-void main()
+
+bool TranslateToWater(inout vec3 refracted)
 {
 	float Refraction = 0.3;
-	vec4 vertex   = ModelMat * vec4(position, 1.0);
-	vsNormal = NormalMat * normal;
 
+	vec4 vertex   = ModelMat * vec4(position, 1.0);
 	gl_Position = ViewMat * vertex;
-	vsPosition = ProjectionMat * gl_Position;
-	vsPosition = vsPosition / (vsPosition.w * 2) + 0.5;
-
 	vec3 pos3 = vec3(gl_Position);
 
-
-	float D = WaterPlane.w + 1 * sin(dot(WaveDirection, pos3 - WaveOffset) * 0.1 + Ph);
 	vec3 n = vec3(WaterPlane);
 	
-	
 	float d = dot(pos3, n);
-	vsAlpha = 0;
-	
+
 	if(d < 1.0e-6)
 	{
+		float D = WaterPlane.w + 1 * sin(dot(WaveDirection, pos3 - WaveOffset) * 0.1 + Ph);
 		float t = D / d;
 		if (t >= 0 && t <= 1.0)		
 		{
 			vec3 crossWater = pos3 * t; 
 			vec3 underWater = pos3 - crossWater;
 			vec3 alongWater = underWater - dot(underWater, n) * n;
-			vec3 refracted = crossWater + alongWater * Refraction;
+			refracted = crossWater + alongWater * Refraction;
 
+			return true;
+		}
+	}
+	return false;
+}
+
+
+void main()
+{
+	vsAlpha = 0;
+	vec3 refracted;
+
+	if(TranslateToWater(refracted))
+	{
+			//vsAlpha = 0.5;
 			vsAlpha = length(vec3(gl_Position) - refracted) / 20;
 			if(vsAlpha > 0.99) vsAlpha = 0.99;
-
 			gl_Position = vec4(refracted , 1);
 			vsNormal = NormalMat * vec3(0, 1, 0);
-		}
 	}
-	
+
 	gl_Position = ProjectionMat * gl_Position;
-	
 }
 
