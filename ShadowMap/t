diff --git a/ShadowMap/Bin/water.fsh b/ShadowMap/Bin/water.fsh
index 9b30569..4bbabba 100755
--- a/ShadowMap/Bin/water.fsh
+++ b/ShadowMap/Bin/water.fsh
@@ -29,6 +29,7 @@ void main(void)
 		}
 	}
 
+	//float amax = texture2D(depthTexture, vsPosition.xy).x;
 	if(amax < vsPosition.z - 0.001)
 	{
 		discard;
@@ -36,10 +37,10 @@ void main(void)
 
 	color = vec4(0, 0, 1, vsAlpha);
 
-	if(vsAlpha < 0.1)
+	if(vsAlpha < 0.2)
 	{
-		vec4 white = vec4(1, 1 , 1, vsAlpha * 20);
-		float t = vsAlpha * 10;
+		vec4 white = vec4(2, 2, 2, vsAlpha * 10);
+		float t = vsAlpha * 5;
 		color = color * t + white * (1 - t);
 	}
 
diff --git a/ShadowMap/Bin/water.vsh b/ShadowMap/Bin/water.vsh
index 82c2426..b8a1dc5 100755
--- a/ShadowMap/Bin/water.vsh
+++ b/ShadowMap/Bin/water.vsh
@@ -17,45 +17,54 @@ out vec3 vsNormal;
 out vec4 vsPosition;
 out float vsAlpha;
 
-void main()
-{
-	float Refraction = 0.3;
-	vec4 vertex   = ModelMat * vec4(position, 1.0);
-	vsNormal = NormalMat * normal;
-
-	gl_Position = ViewMat * vertex;
-	vsPosition = ProjectionMat * gl_Position;
-	vsPosition = vsPosition / (vsPosition.w * 2) + 0.5;
 
+bool TranslateToWater(inout vec3 refracted)
+{
+	float Refraction = 0.5;
 	vec3 pos3 = vec3(gl_Position);
 
-
-	float D = WaterPlane.w + 1 * sin(dot(WaveDirection, pos3 - WaveOffset) * 0.1 + Ph);
 	vec3 n = vec3(WaterPlane);
-	
-	
 	float d = dot(pos3, n);
-	vsAlpha = 0;
-	
-	if(d < 1.0e-6)
+
+	if(d < 1.0e-12)
 	{
+		float D = WaterPlane.w + 1 * sin(dot(WaveDirection, pos3 - WaveOffset) * 0.1 + Ph);
 		float t = D / d;
 		if (t >= 0 && t <= 1.0)		
 		{
 			vec3 crossWater = pos3 * t; 
 			vec3 underWater = pos3 - crossWater;
 			vec3 alongWater = underWater - dot(underWater, n) * n;
-			vec3 refracted = crossWater + alongWater * Refraction;
+			refracted = crossWater + alongWater * Refraction;
+
+			return true;
+		}
+	}
+	return false;
+}
 
-			vsAlpha = length(vec3(gl_Position) - refracted) / 20;
-			if(vsAlpha > 0.99) vsAlpha = 0.99;
 
+void main()
+{
+	vec4 vertex   = ModelMat * vec4(position, 1.0);
+	gl_Position = ViewMat * vertex;
+
+	vsAlpha = 0;
+	vec3 refracted;
+
+	if(TranslateToWater(refracted))
+	{
+			vsAlpha = length(vec3(gl_Position) - refracted) / 20;
+			if(vsAlpha > 0.9) vsAlpha = 0.9;
 			gl_Position = vec4(refracted , 1);
 			vsNormal = NormalMat * vec3(0, 1, 0);
-		}
 	}
-	
+	else
+	{
+		vsNormal = NormalMat * normal;
+	}
+
 	gl_Position = ProjectionMat * gl_Position;
-	
+	vsPosition = gl_Position / (gl_Position.w * 2) + 0.5;
 }
 
diff --git a/ShadowMap/Bin/watershadow.vsh b/ShadowMap/Bin/watershadow.vsh
index 30bb301..40c301d 100755
--- a/ShadowMap/Bin/watershadow.vsh
+++ b/ShadowMap/Bin/watershadow.vsh
@@ -13,16 +13,12 @@ uniform vec3 WaveOffset;
 uniform float Ph;
 
 
-bool TranslateToWater()
+bool TranslateToWater(inout vec3 refracted)
 {
 	float Refraction = 0.3;
-
-	vec4 vertex   = ModelMat * vec4(position, 1.0);
-	gl_Position = ViewMat * vertex;
 	vec3 pos3 = vec3(gl_Position);
 
 	vec3 n = vec3(WaterPlane);
-	
 	float d = dot(pos3, n);
 
 	if(d < 1.0e-6)
@@ -34,9 +30,8 @@ bool TranslateToWater()
 			vec3 crossWater = pos3 * t; 
 			vec3 underWater = pos3 - crossWater;
 			vec3 alongWater = underWater - dot(underWater, n) * n;
-			vec3 refracted = crossWater + alongWater * Refraction;
+			refracted = crossWater + alongWater * Refraction;
 
-			gl_Position = vec4(refracted , 1);
 			return true;
 		}
 	}
@@ -45,33 +40,14 @@ bool TranslateToWater()
 
 void main()
 {
-	float Refraction = 0.3;
 	vec4 vertex   = ModelMat * vec4(position, 1.0);
-
 	gl_Position = ViewMat * vertex;
 
-	vec3 pos3 = vec3(gl_Position);
-
-
-	float D = WaterPlane.w + 1 * sin(dot(WaveDirection, pos3 - WaveOffset) * 0.1 + Ph);
-	vec3 n = vec3(WaterPlane);
-	
-	float d = dot(pos3, n);
-	
-	if(d < 1.0e-6)
+	vec3 refracted;
+	if(TranslateToWater(refracted))
 	{
-		float t = D / d;
-		if (t >= 0 && t <= 1.0)		
-		{
-			vec3 crossWater = pos3 * t; 
-			vec3 underWater = pos3 - crossWater;
-			vec3 alongWater = underWater - dot(underWater, n) * n;
-			vec3 refracted = crossWater + alongWater * Refraction;
-
-			gl_Position = vec4(refracted , 1);
-		}
+		gl_Position = vec4(refracted , 1);
 	}
-	
 	gl_Position = ProjectionMat * gl_Position;
 }
 
